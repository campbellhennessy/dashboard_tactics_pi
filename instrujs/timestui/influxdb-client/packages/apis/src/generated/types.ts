// This file is generated by [oats][0] and should not be edited by hand.
//
// [0]: https://github.com/influxdata/oats

export interface Error {
  /** Code is the machine-readable error code. */
  readonly code:
    | 'internal error'
    | 'not found'
    | 'conflict'
    | 'invalid'
    | 'unprocessable entity'
    | 'empty value'
    | 'unavailable'
    | 'forbidden'
    | 'too many requests'
    | 'unauthorized'
    | 'method not allowed'
  /** Message is a human-readable message. */
  readonly message: string
}

export interface Routes {
  authorizations?: string
  buckets?: string
  dashboards?: string
  external?: {
    statusFeed?: string
  }
  variables?: string
  me?: string
  orgs?: string
  query?: {
    self?: string
    ast?: string
    analyze?: string
    suggestions?: string
  }
  setup?: string
  signin?: string
  signout?: string
  sources?: string
  system?: {
    metrics?: string
    debug?: string
    health?: string
  }
  tasks?: string
  telegrafs?: string
  users?: string
  write?: string
}

export interface IsOnboarding {
  /** True means that the influxdb instance has NOT had initial setup; false means that the database has been setup. */
  allowed?: boolean
}

export interface OnboardingRequest {
  username: string
  password: string
  org: string
  bucket: string
  retentionPeriodHrs?: number
}

export interface OnboardingResponse {
  user?: User
  org?: Organization
  bucket?: Bucket
  auth?: Authorization
}

export interface User {
  readonly id?: string
  oauthID?: string
  name: string
  /** If inactive the user is inactive. */
  status?: 'active' | 'inactive'
  readonly links?: {
    self?: string
    logs?: string
  }
}

export interface Organization {
  readonly links?: {
    self?: Link
    members?: Link
    owners?: Link
    labels?: Link
    secrets?: Link
    buckets?: Link
    tasks?: Link
    dashboards?: Link
    logs?: Link
  }
  readonly id?: string
  name: string
  description?: string
  readonly createdAt?: string
  readonly updatedAt?: string
  /** If inactive the organization is inactive. */
  status?: 'active' | 'inactive'
}

/**
 * URI of resource.
 */
export type Link = string

export interface Bucket {
  readonly links?: {
    /** URL to retrieve labels for this bucket */
    labels?: Link
    /** URL to retrieve operation logs for this bucket */
    logs?: Link
    /** URL to retrieve members that can read this bucket */
    members?: Link
    /** URL to retrieve parent organization for this bucket */
    org?: Link
    /** URL to retrieve owners that can read and write to this bucket. */
    owners?: Link
    /** URL for this bucket */
    self?: Link
    /** URL to write line protocol for this bucket */
    write?: Link
  }
  readonly id?: string
  readonly type?: 'user' | 'system'
  name: string
  description?: string
  orgID?: string
  rp?: string
  readonly createdAt?: string
  readonly updatedAt?: string
  retentionRules: RetentionRules
  labels?: Labels
}

/**
 * Rules to expire or retain data.  No rules means data never expires.
 */
export type RetentionRules = RetentionRule[]

export interface RetentionRule {
  type: 'expire'
  /** Duration in seconds for how long data will be kept in the database. */
  everySeconds: number
}

export type Labels = Label[]

export interface Label {
  readonly id?: string
  readonly orgID?: string
  name?: string
  /** Key/Value pairs associated with this label. Keys can be removed by sending an update with an empty value. */
  properties?: any
}

export type Authorization = AuthorizationUpdateRequest & {
  readonly createdAt?: string
  readonly updatedAt?: string
  /** ID of org that authorization is scoped to. */
  orgID?: string
  /** List of permissions for an auth.  An auth must have at least one Permission. */
  permissions?: Permission[]
  readonly id?: string
  /** Passed via the Authorization Header and Token Authentication type. */
  readonly token?: string
  /** ID of user that created and owns the token. */
  readonly userID?: string
  /** Name of user that created and owns the token. */
  readonly user?: string
  /** Name of the org token is scoped to. */
  readonly org?: string
  readonly links?: {
    readonly self?: Link
    readonly user?: Link
  }
}

export interface AuthorizationUpdateRequest {
  /** If inactive the token is inactive and requests using the token will be rejected. */
  status?: 'active' | 'inactive'
  /** A description of the token. */
  description?: string
}

export interface Permission {
  action: 'read' | 'write'
  resource: {
    type:
      | 'authorizations'
      | 'buckets'
      | 'dashboards'
      | 'orgs'
      | 'sources'
      | 'tasks'
      | 'telegrafs'
      | 'users'
      | 'variables'
      | 'scrapers'
      | 'secrets'
      | 'labels'
      | 'views'
      | 'documents'
      | 'notificationRules'
      | 'notificationEndpoints'
      | 'checks'
    /** If ID is set that is a permission for a specific resource. if it is not set it is a permission for all resources of that resource type. */
    id?: string
    /** Optional name of the resource if the resource has a name field. */
    name?: string
    /** If orgID is set that is a permission for all resources owned my that org. if it is not set it is a permission for all resources of that resource type. */
    orgID?: string
    /** Optional name of the organization of the organization with orgID. */
    org?: string
  }
}

export interface Documents {
  documents?: DocumentListEntry[]
}

export interface DocumentListEntry {
  readonly id: string
  meta: DocumentMeta
  labels?: Labels
  readonly links?: {
    /** The document URL. */
    self?: Link
  }
}

export interface DocumentMeta {
  name: string
  type?: string
  templateID?: string
  description?: string
  version: string
  readonly createdAt?: string
  readonly updatedAt?: string
}

export interface DocumentCreate {
  meta: DocumentMeta
  content: any
  /** The organization Name. Specify either `orgID` or `org`. */
  org?: string
  /** The organization Name. Specify either `orgID` or `org`. */
  orgID?: string
  /** An array of label IDs to be added as labels to the document. */
  labels?: string[]
}

export interface Document {
  readonly id: string
  meta: DocumentMeta
  content: any
  labels?: Labels
  readonly links?: {
    /** The document URL. */
    self?: Link
  }
}

export interface DocumentUpdate {
  meta?: DocumentMeta
  content?: any
}

export interface LabelsResponse {
  labels?: Labels
  links?: Links
}

export interface Links {
  next?: Link
  self: Link
  prev?: Link
}

export interface LabelMapping {
  labelID?: string
}

export interface LabelResponse {
  label?: Label
  links?: Links
}

export interface TelegrafPlugins {
  version?: string
  os?: string
  plugins?: TelegrafPlugin[]
}

export interface TelegrafPlugin {
  type?: string
  name?: string
  description?: string
  config?: string
}

export interface Telegrafs {
  configurations?: Telegraf[]
}

export type Telegraf = TelegrafRequest & {
  readonly id?: string
  readonly links?: {
    self?: Link
    labels?: Link
    members?: Link
    owners?: Link
  }
  readonly labels?: Labels
}

export interface TelegrafRequest {
  name?: string
  description?: string
  metadata?: {
    buckets?: string[]
  }
  config?: string
  orgID?: string
}

export interface ResourceMembers {
  links?: {
    self?: string
  }
  users?: ResourceMember[]
}

export type ResourceMember = User & {
  role?: 'member'
}

export interface AddResourceMemberRequestBody {
  id: string
  name?: string
}

export interface ResourceOwners {
  links?: {
    self?: string
  }
  users?: ResourceOwner[]
}

export type ResourceOwner = User & {
  role?: 'owner'
}

export interface ScraperTargetResponses {
  configurations?: ScraperTargetResponse[]
}

export type ScraperTargetResponse = ScraperTargetRequest & {
  readonly id?: string
  /** The organization name. */
  org?: string
  /** The bucket name. */
  bucket?: string
  readonly links?: {
    self?: Link
    members?: Link
    owners?: Link
    bucket?: Link
    organization?: Link
  }
}

export interface ScraperTargetRequest {
  /** The name of the scraper target. */
  name?: string
  /** The type of the metrics to be parsed. */
  type?: 'prometheus'
  /** The URL of the metrics endpoint. */
  url?: string
  /** The organization ID. */
  orgID?: string
  /** The ID of the bucket to write to. */
  bucketID?: string
}

export interface Variables {
  variables?: Variable[]
}

export interface Variable {
  readonly links?: {
    self?: string
    org?: string
    labels?: string
  }
  readonly id?: string
  orgID: string
  name: string
  description?: string
  selected?: string[]
  labels?: Labels
  arguments: VariableProperties
  createdAt?: string
  updatedAt?: string
}

export type VariableProperties =
  | QueryVariableProperties
  | ConstantVariableProperties
  | MapVariableProperties

export interface QueryVariableProperties {
  type?: 'query'
  values?: {
    query?: string
    language?: string
  }
}

export interface ConstantVariableProperties {
  type?: 'constant'
  values?: string[]
}

export interface MapVariableProperties {
  type?: 'map'
  values?: any
}

export interface LineProtocolError {
  /** Code is the machine-readable error code. */
  readonly code:
    | 'internal error'
    | 'not found'
    | 'conflict'
    | 'invalid'
    | 'empty value'
    | 'unavailable'
  /** Message is a human-readable message. */
  readonly message: string
  /** Op describes the logical code operation during error. Useful for debugging. */
  readonly op: string
  /** Err is a stack of errors that occurred during processing of the request. Useful for debugging. */
  readonly err: string
  /** First line within sent body containing malformed data */
  readonly line?: number
}

export interface LineProtocolLengthError {
  /** Code is the machine-readable error code. */
  readonly code: 'invalid'
  /** Message is a human-readable message. */
  readonly message: string
  /** Max length in bytes for a body of line-protocol. */
  readonly maxLength: number
}

/**
 * The delete predicate request.
 */
export interface DeletePredicateRequest {
  /** RFC3339Nano */
  start: string
  /** RFC3339Nano */
  stop: string
  /** InfluxQL-like delete statement */
  predicate?: string
}

export interface Ready {
  status?: 'ready'
  started?: string
  up?: string
}

export interface HealthCheck {
  name: string
  message?: string
  checks?: HealthCheck[]
  status: 'pass' | 'fail'
}

export interface Sources {
  links?: {
    self?: string
  }
  sources?: Source[]
}

export interface Source {
  links?: {
    self?: string
    query?: string
    health?: string
    buckets?: string
  }
  id?: string
  orgID?: string
  default?: boolean
  name?: string
  type?: 'v1' | 'v2' | 'self'
  url?: string
  insecureSkipVerify?: boolean
  telegraf?: string
  token?: string
  username?: string
  password?: string
  sharedSecret?: string
  metaUrl?: string
  defaultRP?: string
  readonly languages?: Array<'flux' | 'influxql'>
}

export interface Buckets {
  readonly links?: Links
  buckets?: Bucket[]
}

export interface LabelCreateRequest {
  orgID: string
  name?: string
  /** Key/Value pairs associated with this label. Keys can be removed by sending an update with an empty value. */
  properties?: any
}

export interface LabelUpdate {
  name?: string
  /** Key/Value pairs associated with this label. Keys can be removed by sending an update with an empty value. */
  properties?: any
}

export interface Dashboards {
  links?: Links
  dashboards?: Dashboard[]
}

export type Dashboard = CreateDashboardRequest & {
  links?: {
    self?: Link
    cells?: Link
    members?: Link
    owners?: Link
    logs?: Link
    labels?: Link
    org?: Link
  }
  readonly id?: string
  meta?: {
    createdAt?: string
    updatedAt?: string
  }
  cells?: Cells
  labels?: Labels
}

export interface CreateDashboardRequest {
  /** The ID of the organization that owns the dashboard. */
  orgID: string
  /** The user-facing name of the dashboard. */
  name: string
  /** The user-facing description of the dashboard. */
  description?: string
}

export type Cells = Cell[]

export interface Cell {
  id?: string
  links?: {
    self?: string
    view?: string
  }
  x?: number
  y?: number
  w?: number
  h?: number
  /** The reference to a view from the views API. */
  viewID?: string
}

export type DashboardWithViewProperties = CreateDashboardRequest & {
  links?: {
    self?: Link
    cells?: Link
    members?: Link
    owners?: Link
    logs?: Link
    labels?: Link
    org?: Link
  }
  readonly id?: string
  meta?: {
    createdAt?: string
    updatedAt?: string
  }
  cells?: CellsWithViewProperties
  labels?: Labels
}

export type CellsWithViewProperties = CellWithViewProperties[]

export type CellWithViewProperties = Cell & {
  name?: string
  properties?: ViewProperties
}

export type ViewProperties =
  | LinePlusSingleStatProperties
  | XYViewProperties
  | SingleStatViewProperties
  | HistogramViewProperties
  | GaugeViewProperties
  | TableViewProperties
  | MarkdownViewProperties
  | CheckViewProperties
  | ScatterViewProperties
  | HeatmapViewProperties

export interface LinePlusSingleStatProperties {
  type: 'line-plus-single-stat'
  queries: DashboardQuery[]
  /** Colors define color encoding of data into a visualization */
  colors: DashboardColor[]
  shape: 'chronograf-v2'
  note: string
  /** If true, will display note when empty */
  showNoteWhenEmpty: boolean
  axes: Axes
  legend: Legend
  xColumn?: string
  yColumn?: string
  shadeBelow?: boolean
  position: 'overlaid' | 'stacked'
  prefix: string
  suffix: string
  decimalPlaces: DecimalPlaces
}

export interface DashboardQuery {
  /** The text of the Flux query. */
  text?: string
  editMode?: QueryEditMode
  name?: string
  builderConfig?: BuilderConfig
}

export type QueryEditMode = 'builder' | 'advanced'

export interface BuilderConfig {
  buckets?: string[]
  tags?: BuilderTagsType[]
  functions?: BuilderFunctionsType[]
  aggregateWindow?: {
    period?: string
  }
}

export interface BuilderTagsType {
  key?: string
  values?: string[]
  aggregateFunctionType?: BuilderAggregateFunctionType
}

export type BuilderAggregateFunctionType = 'filter' | 'group'

export interface BuilderFunctionsType {
  name?: string
}

/**
 * Defines an encoding of data value into color space.
 */
export interface DashboardColor {
  /** The unique ID of the view color. */
  id: string
  /** Type is how the color is used. */
  type: 'min' | 'max' | 'threshold' | 'scale' | 'text' | 'background'
  /** The hex number of the color */
  hex: string
  /** The user-facing name of the hex color. */
  name: string
  /** The data value mapped to this color. */
  value: number
}

/**
 * The viewport for a View's visualizations
 */
export interface Axes {
  x: Axis
  y: Axis
}

/**
 * The description of a particular axis for a visualization.
 */
export interface Axis {
  /** The extents of an axis in the form [lower, upper]. Clients determine whether bounds are to be inclusive or exclusive of their limits */
  bounds?: string[]
  /** Label is a description of this Axis */
  label?: string
  /** Prefix represents a label prefix for formatting axis values. */
  prefix?: string
  /** Suffix represents a label suffix for formatting axis values. */
  suffix?: string
  /** Base represents the radix for formatting axis values. */
  base?: '' | '2' | '10'
  scale?: AxisScale
}

/**
 * Scale is the axis formatting scale. Supported: "log", "linear"
 */
export type AxisScale = 'log' | 'linear'

/**
 * Legend define encoding of data into a view's legend
 */
export interface Legend {
  /** The style of the legend. */
  type?: 'static'
  /** orientation is the location of the legend with respect to the view graph */
  orientation?: 'top' | 'bottom' | 'left' | 'right'
}

/**
 * Indicates whether decimal places should be enforced, and how many digits it should show.
 */
export interface DecimalPlaces {
  /** Indicates whether decimal point setting should be enforced */
  isEnforced?: boolean
  /** The number of digits after decimal to display */
  digits?: number
}

export interface XYViewProperties {
  timeFormat?: string
  type: 'xy'
  queries: DashboardQuery[]
  /** Colors define color encoding of data into a visualization */
  colors: DashboardColor[]
  shape: 'chronograf-v2'
  note: string
  /** If true, will display note when empty */
  showNoteWhenEmpty: boolean
  axes: Axes
  legend: Legend
  xColumn?: string
  yColumn?: string
  shadeBelow?: boolean
  position: 'overlaid' | 'stacked'
  geom: XYGeom
}

export type XYGeom = 'line' | 'step' | 'stacked' | 'bar' | 'monotoneX'

export interface SingleStatViewProperties {
  type: 'single-stat'
  queries: DashboardQuery[]
  /** Colors define color encoding of data into a visualization */
  colors: DashboardColor[]
  shape: 'chronograf-v2'
  note: string
  /** If true, will display note when empty */
  showNoteWhenEmpty: boolean
  prefix: string
  tickPrefix: string
  suffix: string
  tickSuffix: string
  legend: Legend
  decimalPlaces: DecimalPlaces
}

export interface HistogramViewProperties {
  type: 'histogram'
  queries: DashboardQuery[]
  /** Colors define color encoding of data into a visualization */
  colors: DashboardColor[]
  shape: 'chronograf-v2'
  note: string
  /** If true, will display note when empty */
  showNoteWhenEmpty: boolean
  xColumn: string
  fillColumns: string[]
  xDomain: number[]
  xAxisLabel: string
  position: 'overlaid' | 'stacked'
  binCount: number
}

export interface GaugeViewProperties {
  type: 'gauge'
  queries: DashboardQuery[]
  /** Colors define color encoding of data into a visualization */
  colors: DashboardColor[]
  shape: 'chronograf-v2'
  note: string
  /** If true, will display note when empty */
  showNoteWhenEmpty: boolean
  prefix: string
  tickPrefix: string
  suffix: string
  tickSuffix: string
  legend: Legend
  decimalPlaces: DecimalPlaces
}

export interface TableViewProperties {
  type: 'table'
  queries: DashboardQuery[]
  /** Colors define color encoding of data into a visualization */
  colors: DashboardColor[]
  shape: 'chronograf-v2'
  note: string
  /** If true, will display note when empty */
  showNoteWhenEmpty: boolean
  tableOptions: {
    /** verticalTimeAxis describes the orientation of the table by indicating whether the time axis will be displayed vertically */
    verticalTimeAxis?: boolean
    sortBy?: RenamableField
    /** Wrapping describes the text wrapping style to be used in table views */
    wrapping?: 'truncate' | 'wrap' | 'single-line'
    /** fixFirstColumn indicates whether the first column of the table should be locked */
    fixFirstColumn?: boolean
  }
  /** fieldOptions represent the fields retrieved by the query with customization options */
  fieldOptions: RenamableField[]
  /** timeFormat describes the display format for time values according to moment.js date formatting */
  timeFormat: string
  decimalPlaces: DecimalPlaces
}

/**
 * Describes a field that can be renamed and made visible or invisible.
 */
export interface RenamableField {
  /** The calculated name of a field. */
  readonly internalName?: string
  /** The name that a field is renamed to by the user. */
  displayName?: string
  /** Indicates whether this field should be visible on the table. */
  visible?: boolean
}

export interface MarkdownViewProperties {
  type: 'markdown'
  shape: 'chronograf-v2'
  note: string
}

export interface CheckViewProperties {
  type: 'check'
  shape: 'chronograf-v2'
  checkID: string
  check?: Check
  queries: DashboardQuery[]
  /** Colors define color encoding of data into a visualization */
  colors: string[]
}

export type Check = CheckDiscriminator

export type CheckDiscriminator =
  | (DeadmanCheck & {type: string})
  | (ThresholdCheck & {type: string})
  | (CustomCheck & {type: string})

export type DeadmanCheck = CheckBase & {
  type: 'deadman'
  /** String duration before deadman triggers. */
  timeSince?: string
  /** String duration for time that a series is considered stale and should not trigger deadman. */
  staleTime?: string
  /** If only zero values reported since time, trigger an alert */
  reportZero?: boolean
  level?: CheckStatusLevel
  /** Check repetition interval. */
  every?: string
  /** Duration to delay after the schedule, before executing check. */
  offset?: string
  /** List of tags to write to each status. */
  tags?: Array<{
    key?: string
    value?: string
  }>
  /** The template used to generate and write a status message. */
  statusMessageTemplate?: string
}

export interface CheckBase {
  readonly id?: string
  name: string
  /** The ID of the organization that owns this check. */
  orgID: string
  /** The ID of creator used to create this check. */
  readonly ownerID?: string
  readonly createdAt?: string
  readonly updatedAt?: string
  query: DashboardQuery
  status?: TaskStatusType
  /** An optional description of the check. */
  description?: string
  /** Timestamp of latest scheduled, completed run, RFC3339. */
  readonly latestCompleted?: string
  readonly lastRunStatus?: 'failed' | 'success' | 'canceled'
  readonly lastRunError?: string
  labels?: Labels
  readonly links?: {
    /** URL for this check */
    self?: Link
    /** URL to retrieve labels for this check */
    labels?: Link
    /** URL to retrieve members for this check */
    members?: Link
    /** URL to retrieve owners for this check */
    owners?: Link
    /** URL to retrieve flux script for this check */
    query?: Link
  }
}

export type TaskStatusType = 'active' | 'inactive'

/**
 * The state to record if check matches a criteria.
 */
export type CheckStatusLevel = 'UNKNOWN' | 'OK' | 'INFO' | 'CRIT' | 'WARN'

export type ThresholdCheck = CheckBase & {
  type: 'threshold'
  thresholds?: Threshold[]
  /** Check repetition interval. */
  every?: string
  /** Duration to delay after the schedule, before executing check. */
  offset?: string
  /** List of tags to write to each status. */
  tags?: Array<{
    key?: string
    value?: string
  }>
  /** The template used to generate and write a status message. */
  statusMessageTemplate?: string
}

export type Threshold =
  | (GreaterThreshold & {type: string})
  | (LesserThreshold & {type: string})
  | (RangeThreshold & {type: string})

export type GreaterThreshold = ThresholdBase & {
  type: 'greater'
  value: number
}

export interface ThresholdBase {
  level?: CheckStatusLevel
  /** If true, only alert if all values meet threshold. */
  allValues?: boolean
}

export type LesserThreshold = ThresholdBase & {
  type: 'lesser'
  value: number
}

export type RangeThreshold = ThresholdBase & {
  type: 'range'
  min: number
  max: number
  within: boolean
}

export type CustomCheck = CheckBase & {
  type: 'custom'
}

export interface ScatterViewProperties {
  timeFormat?: string
  type: 'scatter'
  queries: DashboardQuery[]
  /** Colors define color encoding of data into a visualization */
  colors: string[]
  shape: 'chronograf-v2'
  note: string
  /** If true, will display note when empty */
  showNoteWhenEmpty: boolean
  xColumn: string
  yColumn: string
  fillColumns: string[]
  symbolColumns: string[]
  xDomain: number[]
  yDomain: number[]
  xAxisLabel: string
  yAxisLabel: string
  xPrefix: string
  xSuffix: string
  yPrefix: string
  ySuffix: string
}

export interface HeatmapViewProperties {
  timeFormat?: string
  type: 'heatmap'
  queries: DashboardQuery[]
  /** Colors define color encoding of data into a visualization */
  colors: string[]
  shape: 'chronograf-v2'
  note: string
  /** If true, will display note when empty */
  showNoteWhenEmpty: boolean
  xColumn: string
  yColumn: string
  xDomain: number[]
  yDomain: number[]
  xAxisLabel: string
  yAxisLabel: string
  xPrefix: string
  xSuffix: string
  yPrefix: string
  ySuffix: string
  binSize: number
}

export interface CreateCell {
  name?: string
  x?: number
  y?: number
  w?: number
  h?: number
  /** Makes a copy of the provided view. */
  usingView?: string
}

export interface CellUpdate {
  x?: number
  y?: number
  w?: number
  h?: number
}

export interface View {
  readonly links?: {
    self?: string
  }
  readonly id?: string
  name: string
  properties: ViewProperties
}

export interface OperationLogs {
  logs?: OperationLog[]
  links?: Links
}

export interface OperationLog {
  /** A description of the event that occurred. */
  description?: string
  /** Time event occurred, RFC3339Nano. */
  time?: string
  /** ID of the user who operated the event. */
  userID?: string
  links?: {
    user?: Link
  }
}

/**
 * Flux query to be analyzed.
 */
export interface LanguageRequest {
  /** Flux query script to be analyzed */
  query: string
}

/**
 * Contains the AST for the supplied Flux query
 */
export interface ASTResponse {
  ast?: Package
}

/**
 * Represents a complete package source tree.
 */
export interface Package {
  type?: NodeType
  /** Package import path */
  path?: string
  /** Package name */
  package?: string
  /** Package files */
  files?: File[]
}

/**
 * Type of AST node
 */
export type NodeType = string

/**
 * Represents a source from a single file
 */
export interface File {
  type?: NodeType
  /** The name of the file. */
  name?: string
  package?: PackageClause
  /** A list of package imports */
  imports?: ImportDeclaration[]
  /** List of Flux statements */
  body?: Statement[]
}

/**
 * Defines a package identifier
 */
export interface PackageClause {
  type?: NodeType
  name?: Identifier
}

/**
 * A valid Flux identifier
 */
export interface Identifier {
  type?: NodeType
  name?: string
}

/**
 * Declares a package import
 */
export interface ImportDeclaration {
  type?: NodeType
  as?: Identifier
  path?: StringLiteral
}

/**
 * Expressions begin and end with double quote marks
 */
export interface StringLiteral {
  type?: NodeType
  value?: string
}

export type Statement =
  | BadStatement
  | VariableAssignment
  | MemberAssignment
  | ExpressionStatement
  | ReturnStatement
  | OptionStatement
  | BuiltinStatement
  | TestStatement

/**
 * A placeholder for statements for which no correct statement nodes can be created
 */
export interface BadStatement {
  type?: NodeType
  /** Raw source text */
  text?: string
}

/**
 * Represents the declaration of a variable
 */
export interface VariableAssignment {
  type?: NodeType
  id?: Identifier
  init?: Expression
}

export type Expression =
  | ArrayExpression
  | FunctionExpression
  | BinaryExpression
  | CallExpression
  | ConditionalExpression
  | LogicalExpression
  | MemberExpression
  | IndexExpression
  | ObjectExpression
  | ParenExpression
  | PipeExpression
  | UnaryExpression
  | BooleanLiteral
  | DateTimeLiteral
  | DurationLiteral
  | FloatLiteral
  | IntegerLiteral
  | PipeLiteral
  | RegexpLiteral
  | StringLiteral
  | UnsignedIntegerLiteral
  | Identifier

/**
 * Used to create and directly specify the elements of an array object
 */
export interface ArrayExpression {
  type?: NodeType
  /** Elements of the array */
  elements?: Expression[]
}

/**
 * Function expression
 */
export interface FunctionExpression {
  type?: NodeType
  /** Function parameters */
  params?: Property[]
  body?: Node
}

/**
 * The value associated with a key
 */
export interface Property {
  type?: NodeType
  key?: PropertyKey
  value?: Expression
}

export type PropertyKey = Identifier | StringLiteral

export type Node = Expression | Block

/**
 * A set of statements
 */
export interface Block {
  type?: NodeType
  /** Block body */
  body?: Statement[]
}

/**
 * uses binary operators to act on two operands in an expression
 */
export interface BinaryExpression {
  type?: NodeType
  operator?: string
  left?: Expression
  right?: Expression
}

/**
 * Represents a function call
 */
export interface CallExpression {
  type?: NodeType
  callee?: Expression
  /** Function arguments */
  arguments?: Expression[]
}

/**
 * Selects one of two expressions, `Alternate` or `Consequent`, depending on a third boolean expression, `Test`
 */
export interface ConditionalExpression {
  type?: NodeType
  test?: Expression
  alternate?: Expression
  consequent?: Expression
}

/**
 * Represents the rule conditions that collectively evaluate to either true or false
 */
export interface LogicalExpression {
  type?: NodeType
  operator?: string
  left?: Expression
  right?: Expression
}

/**
 * Represents accessing a property of an object
 */
export interface MemberExpression {
  type?: NodeType
  object?: Expression
  property?: PropertyKey
}

/**
 * Represents indexing into an array
 */
export interface IndexExpression {
  type?: NodeType
  array?: Expression
  index?: Expression
}

/**
 * Allows the declaration of an anonymous object within a declaration
 */
export interface ObjectExpression {
  type?: NodeType
  /** Object properties */
  properties?: Property[]
}

/**
 * Represents an expression wrapped in parenthesis
 */
export interface ParenExpression {
  type?: NodeType
  expression?: Expression
}

/**
 * Call expression with pipe argument
 */
export interface PipeExpression {
  type?: NodeType
  argument?: Expression
  call?: CallExpression
}

/**
 * Uses operators to act on a single operand in an expression
 */
export interface UnaryExpression {
  type?: NodeType
  operator?: string
  argument?: Expression
}

/**
 * Represents boolean values
 */
export interface BooleanLiteral {
  type?: NodeType
  value?: boolean
}

/**
 * Represents an instant in time with nanosecond precision using the syntax of golang's RFC3339 Nanosecond variant
 */
export interface DateTimeLiteral {
  type?: NodeType
  value?: string
}

/**
 * Represents the elapsed time between two instants as an int64 nanosecond count with syntax of golang's time.Duration
 */
export interface DurationLiteral {
  type?: NodeType
  /** Duration values */
  values?: Duration[]
}

/**
 * A pair consisting of length of time and the unit of time measured. It is the atomic unit from which all duration literals are composed.
 */
export interface Duration {
  type?: NodeType
  magnitude?: number
  unit?: string
}

/**
 * Represents floating point numbers according to the double representations defined by the IEEE-754-1985
 */
export interface FloatLiteral {
  type?: NodeType
  value?: number
}

/**
 * Represents integer numbers
 */
export interface IntegerLiteral {
  type?: NodeType
  value?: string
}

/**
 * Represents a specialized literal value, indicating the left hand value of a pipe expression
 */
export interface PipeLiteral {
  type?: NodeType
}

/**
 * Expressions begin and end with `/` and are regular expressions with syntax accepted by RE2
 */
export interface RegexpLiteral {
  type?: NodeType
  value?: string
}

/**
 * Represents integer numbers
 */
export interface UnsignedIntegerLiteral {
  type?: NodeType
  value?: string
}

/**
 * Object property assignment
 */
export interface MemberAssignment {
  type?: NodeType
  member?: MemberExpression
  init?: Expression
}

/**
 * May consist of an expression that does not return a value and is executed solely for its side-effects
 */
export interface ExpressionStatement {
  type?: NodeType
  expression?: Expression
}

/**
 * Defines an expression to return
 */
export interface ReturnStatement {
  type?: NodeType
  argument?: Expression
}

/**
 * A single variable declaration
 */
export interface OptionStatement {
  type?: NodeType
  assignment?: VariableAssignment | MemberAssignment
}

/**
 * Declares a builtin identifier and its type
 */
export interface BuiltinStatement {
  type?: NodeType
  id?: Identifier
}

/**
 * Declares a Flux test case
 */
export interface TestStatement {
  type?: NodeType
  assignment?: VariableAssignment
}

export interface FluxSuggestions {
  funcs?: FluxSuggestion[]
}

export interface FluxSuggestion {
  name?: string
  params?: any
}

export interface Authorizations {
  readonly links?: Links
  authorizations?: Authorization[]
}

/**
 * Query influx using the Flux language
 */
export interface Query {
  extern?: File
  /** Query script to execute. */
  query: string
  /** The type of query. Must be "flux". */
  type?: 'flux'
  dialect?: Dialect
}

/**
 * Dialect are options to change the default CSV output format; https://www.w3.org/TR/2015/REC-tabular-metadata-20151217/#dialect-descriptions
 */
export interface Dialect {
  /** If true, the results will contain a header row */
  header?: boolean
  /** Separator between cells; the default is , */
  delimiter?: string
  /** Https://www.w3.org/TR/2015/REC-tabular-data-model-20151217/#columns */
  annotations?: Array<'group' | 'datatype' | 'default'>
  /** Character prefixed to comment strings */
  commentPrefix?: string
  /** Format of timestamps */
  dateTimeFormat?: 'RFC3339' | 'RFC3339Nano'
}

export interface AnalyzeQueryResponse {
  errors?: Array<{
    line?: number
    column?: number
    character?: number
    message?: string
  }>
}

/**
 * Query influx using the InfluxQL language
 */
export interface InfluxQLQuery {
  /** InfluxQL query execute. */
  query: string
  /** The type of query. Must be "influxql". */
  type?: 'influxql'
  /** Bucket is to be used instead of the database and retention policy specified in the InfluxQL query. */
  bucket?: string
}

export interface PostBucketRequest {
  orgID?: string
  name: string
  description?: string
  rp?: string
  retentionRules: RetentionRules
}

export interface Organizations {
  links?: Links
  orgs?: Organization[]
}

export type SecretKeysResponse = SecretKeys & {
  readonly links?: {
    self?: string
    org?: string
  }
}

export interface SecretKeys {
  secrets?: string[]
}

export type Secrets = any

export interface PkgCreate {
  orgIDs?: string[]
  resources?: {
    id: string
    kind:
      | 'bucket'
      | 'check'
      | 'dashboard'
      | 'label'
      | 'notification_endpoint'
      | 'notification_rule'
      | 'task'
      | 'telegraf'
      | 'variable'
    name?: string
  }
}

export type Pkg = Array<{
  apiVersion?: string
  kind?:
    | 'Bucket'
    | 'CheckDeadman'
    | 'CheckThreshold'
    | 'Dashboard'
    | 'Label'
    | 'NotificationEndpointHTTP'
    | 'NotificationEndpointPagerDuty'
    | 'NotificationEndpointSlack'
    | 'NotificationRule'
    | 'NotificationEndpointHTTP'
    | 'Task'
    | 'Telegraf'
    | 'Variable'
  meta?: {
    name?: string
  }
  spec?: any
}>

export interface PkgApply {
  dryRun?: boolean
  orgID?: string
  package?: Pkg
  packages?: Pkg[]
  secrets?: any
  remotes?: Array<{
    url: string
    contentType?: string
  }>
}

export interface PkgSummary {
  summary?: {
    buckets?: Array<{
      id?: string
      orgID?: string
      name?: string
      description?: string
      retentionPeriod?: number
      labelAssociations?: PkgSummaryLabel[]
    }>
    checks?: Array<
      CheckDiscriminator & {
        labelAssociations?: PkgSummaryLabel[]
      }
    >
    labels?: PkgSummaryLabel[]
    dashboards?: Array<{
      id?: string
      orgID?: string
      name?: string
      description?: string
      labelAssociations?: PkgSummaryLabel[]
      charts?: PkgChart[]
    }>
    labelMappings?: Array<{
      resourceName?: string
      resourceID?: string
      resourceType?: string
      labelName?: string
      labelID?: string
    }>
    missingEnvRefs?: string[]
    missingSecrets?: string[]
    notificationEndpoints?: Array<
      NotificationEndpointDiscrimator & {
        labelAssociations?: PkgSummaryLabel[]
      }
    >
    notificationRules?: Array<{
      name?: string
      description?: string
      endpointName?: string
      endpointID?: string
      endpointType?: string
      every?: string
      offset?: string
      messageTemplate?: string
      status?: string
      statusRules?: Array<{
        currentLevel?: string
        previousLevel?: string
      }>
      tagRules?: Array<{
        key?: string
        value?: string
        operator?: string
      }>
      labelAssociations?: PkgSummaryLabel[]
    }>
    tasks?: Array<{
      id?: string
      name?: string
      cron?: string
      description?: string
      every?: string
      offset?: string
      query?: string
      status?: string
    }>
    telegrafConfigs?: Array<
      TelegrafRequest & {
        labelAssociations?: PkgSummaryLabel[]
      }
    >
    variables?: Array<{
      id?: string
      orgID?: string
      name?: string
      description?: string
      arguments?: VariableProperties
      labelAssociations?: PkgSummaryLabel[]
    }>
  }
  diff?: {
    buckets?: Array<{
      id?: string
      name?: string
      new?: {
        description?: string
        retentionRules?: RetentionRules
      }
      old?: {
        description?: string
        retentionRules?: RetentionRules
      }
    }>
    checks?: Array<{
      id?: string
      name?: string
      new?: CheckDiscriminator
      old?: CheckDiscriminator
    }>
    dashboards?: Array<{
      name?: string
      description?: string
      charts?: PkgChart[]
    }>
    labels?: Array<{
      id?: string
      name?: string
      new?: {
        color?: string
        description?: string
      }
      old?: {
        color?: string
        description?: string
      }
    }>
    labelMappings?: Array<{
      isNew?: boolean
      resourceType?: string
      resourceID?: string
      resourceName?: string
      labelID?: string
      labelName?: string
    }>
    notificationEndpoints?: Array<{
      id?: string
      name?: string
      new?: NotificationEndpointDiscrimator
      old?: NotificationEndpointDiscrimator
    }>
    notificationRules?: Array<{
      name?: string
      description?: string
      endpointName?: string
      endpointID?: string
      endpointType?: string
      every?: string
      offset?: string
      messageTemplate?: string
      status?: string
      statusRules?: Array<{
        currentLevel?: string
        previousLevel?: string
      }>
      tagRules?: Array<{
        key?: string
        value?: string
        operator?: string
      }>
    }>
    tasks?: Array<{
      name?: string
      cron?: string
      description?: string
      every?: string
      offset?: string
      query?: string
      status?: string
    }>
    telegrafConfigs?: TelegrafRequest[]
    variables?: Array<{
      id?: string
      name?: string
      new?: {
        description?: string
        args?: VariableProperties
      }
      old?: {
        description?: string
        args?: VariableProperties
      }
    }>
  }
  errors?: Array<{
    kind?: string
    reason?: string
    fields?: string[]
    indexes?: number[]
  }>
}

export interface PkgSummaryLabel {
  id?: string
  orgID?: string
  name?: string
  description?: string
  retentionPeriod?: string
}

export interface PkgChart {
  xPos?: number
  yPos?: number
  height?: number
  width?: number
  properties?: ViewProperties
}

export type NotificationEndpointDiscrimator =
  | (SlackNotificationEndpoint & {type: string})
  | (PagerDutyNotificationEndpoint & {type: string})
  | (HTTPNotificationEndpoint & {type: string})

export type SlackNotificationEndpoint = NotificationEndpointBase & {
  /** Specifies the URL of the Slack endpoint. Specify either `URL` or `Token`. */
  url?: string
  /** Specifies the API token string. Specify either `URL` or `Token`. */
  token?: string
}

export interface NotificationEndpointBase {
  id?: string
  orgID?: string
  userID?: string
  readonly createdAt?: string
  readonly updatedAt?: string
  /** An optional description of the notification endpoint. */
  description?: string
  name: string
  /** The status of the endpoint. */
  status?: 'active' | 'inactive'
  labels?: Labels
  readonly links?: {
    /** URL for this endpoint. */
    self?: Link
    /** URL to retrieve labels for this endpoint. */
    labels?: Link
    /** URL to retrieve members for this endpoint. */
    members?: Link
    /** URL to retrieve owners for this endpoint. */
    owners?: Link
  }
  type: NotificationEndpointType
}

export type NotificationEndpointType = 'slack' | 'pagerduty' | 'http'

export type PagerDutyNotificationEndpoint = NotificationEndpointBase & {
  clientURL?: string
  routingKey: string
}

export type HTTPNotificationEndpoint = NotificationEndpointBase & {
  url: string
  username?: string
  password?: string
  token?: string
  method: 'POST' | 'GET' | 'PUT'
  authMethod: 'none' | 'basic' | 'bearer'
  contentTemplate?: string
  /** Customized headers. */
  headers?: any
}

export interface Tasks {
  readonly links?: Links
  tasks?: Task[]
}

export interface Task {
  readonly id: string
  /** The type of task, this can be used for filtering tasks on list actions. */
  type?: string
  /** The ID of the organization that owns this Task. */
  orgID: string
  /** The name of the organization that owns this Task. */
  org?: string
  /** The name of the task. */
  name: string
  /** An optional description of the task. */
  description?: string
  status?: TaskStatusType
  labels?: Labels
  /** The ID of the authorization used when this task communicates with the query engine. */
  authorizationID?: string
  /** The Flux script to run for this task. */
  flux: string
  /** A simple task repetition schedule; parsed from Flux. */
  every?: string
  /** A task repetition schedule in the form '* * * * * *'; parsed from Flux. */
  cron?: string
  /** Duration to delay after the schedule, before executing the task; parsed from flux, if set to zero it will remove this option and use 0 as the default. */
  offset?: string
  /** Timestamp of latest scheduled, completed run, RFC3339. */
  readonly latestCompleted?: string
  readonly lastRunStatus?: 'failed' | 'success' | 'canceled'
  readonly lastRunError?: string
  readonly createdAt?: string
  readonly updatedAt?: string
  readonly links?: {
    self?: Link
    owners?: Link
    members?: Link
    runs?: Link
    logs?: Link
    labels?: Link
  }
}

export interface TaskCreateRequest {
  /** The ID of the organization that owns this Task. */
  orgID?: string
  /** The name of the organization that owns this Task. */
  org?: string
  status?: TaskStatusType
  /** The Flux script to run for this task. */
  flux: string
  /** An optional description of the task. */
  description?: string
}

export interface TaskUpdateRequest {
  status?: TaskStatusType
  /** The Flux script to run for this task. */
  flux?: string
  /** Override the 'name' option in the flux script. */
  name?: string
  /** Override the 'every' option in the flux script. */
  every?: string
  /** Override the 'cron' option in the flux script. */
  cron?: string
  /** Override the 'offset' option in the flux script. */
  offset?: string
  /** An optional description of the task. */
  description?: string
}

export interface Runs {
  links?: Links
  runs?: Run[]
}

export interface Run {
  readonly id?: string
  readonly taskID?: string
  readonly status?: 'scheduled' | 'started' | 'failed' | 'success' | 'canceled'
  /** Time used for run's "now" option, RFC3339. */
  scheduledFor?: string
  /** An array of logs associated with the run. */
  readonly log?: Array<{
    runID?: string
    time?: string
    message?: string
  }>
  /** Time run started executing, RFC3339Nano. */
  readonly startedAt?: string
  /** Time run finished executing, RFC3339Nano. */
  readonly finishedAt?: string
  /** Time run was manually requested, RFC3339Nano. */
  readonly requestedAt?: string
  readonly links?: {
    self?: string
    task?: string
    logs?: string
    retry?: string
  }
}

export interface RunManually {
  /** Time used for run's "now" option, RFC3339.  Default is the server's now time. */
  scheduledFor?: string
}

export interface Logs {
  readonly events?: LogEvent[]
}

export interface LogEvent {
  /** Time event occurred, RFC3339Nano. */
  readonly time?: string
  /** A description of the event that occurred. */
  readonly message?: string
}

export interface PasswordResetBody {
  password: string
}

export interface Users {
  links?: {
    self?: string
  }
  users?: User[]
}

export interface Checks {
  checks?: Check[]
  links?: Links
}

export type PostCheck = CheckDiscriminator

export interface CheckPatch {
  name?: string
  description?: string
  status?: 'active' | 'inactive'
}

export interface NotificationRules {
  notificationRules?: NotificationRule[]
  links?: Links
}

export type NotificationRule = NotificationRuleDiscriminator

export type NotificationRuleDiscriminator =
  | (SlackNotificationRule & {type: string})
  | (SMTPNotificationRule & {type: string})
  | (PagerDutyNotificationRule & {type: string})
  | (HTTPNotificationRule & {type: string})

export type SlackNotificationRule = NotificationRuleBase &
  SlackNotificationRuleBase

export interface NotificationRuleBase {
  /** Timestamp of latest scheduled, completed run, RFC3339. */
  readonly latestCompleted?: string
  readonly lastRunStatus?: 'failed' | 'success' | 'canceled'
  readonly lastRunError?: string
  readonly id: string
  endpointID: string
  /** The ID of the organization that owns this notification rule. */
  orgID: string
  /** The ID of creator used to create this notification rule. */
  readonly ownerID?: string
  readonly createdAt?: string
  readonly updatedAt?: string
  status: TaskStatusType
  /** Human-readable name describing the notification rule. */
  name: string
  sleepUntil?: string
  /** The notification repetition interval. */
  every?: string
  /** Duration to delay after the schedule, before executing check. */
  offset?: string
  runbookLink?: string
  /** Don't notify me more than <limit> times every <limitEvery> seconds. If set, limit cannot be empty. */
  limitEvery?: number
  /** Don't notify me more than <limit> times every <limitEvery> seconds. If set, limitEvery cannot be empty. */
  limit?: number
  /** List of tag rules the notification rule attempts to match. */
  tagRules: TagRule[]
  /** An optional description of the notification rule. */
  description?: string
  /** List of status rules the notification rule attempts to match. */
  statusRules: StatusRule[]
  labels?: Labels
  readonly links?: {
    /** URL for this endpoint. */
    self?: Link
    /** URL to retrieve labels for this notification rule. */
    labels?: Link
    /** URL to retrieve members for this notification rule. */
    members?: Link
    /** URL to retrieve owners for this notification rule. */
    owners?: Link
    /** URL to retrieve flux script for this notification rule. */
    query?: Link
  }
}

export interface TagRule {
  key?: string
  value?: string
  operator?: 'equal' | 'notequal' | 'equalregex' | 'notequalregex'
}

export interface StatusRule {
  currentLevel?: RuleStatusLevel
  previousLevel?: RuleStatusLevel
  count?: number
  period?: string
}

/**
 * The state to record if check matches a criteria.
 */
export type RuleStatusLevel =
  | 'UNKNOWN'
  | 'OK'
  | 'INFO'
  | 'CRIT'
  | 'WARN'
  | 'ANY'

export interface SlackNotificationRuleBase {
  type: 'slack'
  channel?: string
  messageTemplate: string
}

export type SMTPNotificationRule = NotificationRuleBase &
  SMTPNotificationRuleBase

export interface SMTPNotificationRuleBase {
  type: 'smtp'
  subjectTemplate: string
  bodyTemplate?: string
  to: string
}

export type PagerDutyNotificationRule = NotificationRuleBase &
  PagerDutyNotificationRuleBase

export interface PagerDutyNotificationRuleBase {
  type: 'pagerduty'
  messageTemplate: string
}

export type HTTPNotificationRule = NotificationRuleBase &
  HTTPNotificationRuleBase

export interface HTTPNotificationRuleBase {
  type: 'http'
  url?: string
}

export type PostNotificationRule = NotificationRuleDiscriminator

/**
 * Rendered flux that backs the check or notification.
 */
export interface FluxResponse {
  flux?: string
}

export interface NotificationRuleUpdate {
  name?: string
  description?: string
  status?: 'active' | 'inactive'
}

export interface NotificationEndpoints {
  notificationEndpoints?: NotificationEndpoint[]
  links?: Links
}

export type NotificationEndpoint = NotificationEndpointDiscrimator

export type PostNotificationEndpoint = NotificationEndpointDiscrimator

export interface NotificationEndpointUpdate {
  name?: string
  description?: string
  status?: 'active' | 'inactive'
}
